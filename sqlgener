/* REXX  - GENSQL: INSERT/UPDATE from data file -> 80 FB dataset
   Input dataset:
     - line 1: column headers
     - lines 2..N: values
   Output dataset:
     - <OUTBASE>.(INSERT|UPDATE), PS RECFM=FB LRECL=80
*/

address TSO "CLEAR"
say "==============================="
say "   GENERATOR SQL (INSERT/UPDATE)"
say "==============================="
say

/* --- 1) User input --- */
say "Podaj nazwe tabeli (SCHEMA.TAB):"
parse upper pull TABLENAME
TABLENAME = strip(TABLENAME)
if TABLENAME = "" | pos('.', TABLENAME) = 0 then do
  say "ERROR: Podaj SCHEMA.TAB"
  exit 8
end

say "Podaj DSN z danymi (wejscie), np. HLQ.INPUT.DATA:"
parse pull INDSN
INDSN = strip(INDSN)
if INDSN = "" then do
  say "ERROR: Brak DSN wejsciowego."
  exit 8
end

say "Wybierz operacje (INSERT/UPDATE):"
parse upper pull OP
OP = strip(OP)
if OP <> "INSERT" & OP <> "UPDATE" then do
  say "ERROR: Dozwolone tylko INSERT lub UPDATE."
  exit 8
end

KEYIN = ""
if OP = "UPDATE" then do
  say "Podaj kolumny klucza (nazwy lub indeksy, oddzielone , ; | lub spacjami)."
  say "ENTER = 1. kolumna. Przyklad: ID, BRANCH, EFF_DATE lub 1,3"
  parse pull KEYIN
  KEYIN = strip(KEYIN)
end

say "Podaj BAZOWA nazwe DSN wyjsciowego (bez sufiksu), np. HLQ.OUTPUT.SQL:"
parse pull OUTBASE
OUTBASE = strip(OUTBASE)
if OUTBASE = "" then do
  say "ERROR: Brak bazowej nazwy DSN wyjsciowego."
  exit 8
end

OUTDSN = OUTBASE || '.' || OP         /* e.g., HLQ.OUTPUT.SQL.UPDATE */

/* --- 2) Read input dataset --- */
address TSO
"FREE  FI(INFILE)"
"ALLOC FI(INFILE) DA('"INDSN"') SHR REUSE"
if rc <> 0 then do
  say "ERROR: Cannot ALLOC INFILE '"INDSN"'. RC="rc
  exit 12
end

"EXECIO * DISKR INFILE (FINIS STEM in.)"
if rc <> 0 then do
  say "ERROR: Cannot read INFILE. RC="rc
  "FREE FI(INFILE)"
  exit 12
end
"FREE  FI(INFILE)"
if in.0 = 0 then do
  say "ERROR: Input file is empty."
  exit 12
end

/* --- 3) Utilities (no PROCEDURE anywhere) --- */

changestr:
  parse arg old, s, new
  if old = '' then return s
  do forever
    p = pos(old, s); if p = 0 then leave
    s = delstr(s, p, length(old))
    s = insert(new, s, p-1)
  end
  return s

detectDelim:
  parse arg hdr
  /* Prefer non-space: | , ; TAB; space as last resort */
  alist = '|,;9 B'      /* 9=TAB, B=SPACE */
  best = d2c(32); bestcnt = -1
  do i = 1 to words(alist)
    a = word(alist, i)
    select
      when a = '9' then sep = d2c(9)
      when a = 'B' then sep = d2c(32)
      otherwise        sep = a
    end
    cnt = 0; p = 1
    do while pos(sep, hdr, p) > 0
      p = pos(sep, hdr, p) + 1
      cnt = cnt + 1
    end
    if cnt > bestcnt then do
      best = sep; bestcnt = cnt
    end
  end
  return best

/* splitLine: splits 'line' by 'sep' into a stem named by 'stemname' (e.g., 'cols.') */
splitLine:
  parse arg line, sep, stemname
  if stemname = '' then return 0
  line = strip(line)
  call value stemname||'0', 0
  if line = '' then return 0
  tmp = line; i = 0
  if sep = ' ' then do
    do while tmp <> ''
      parse var tmp fld tmp
      i = i + 1
      call value stemname||i, strip(fld)
    end
  end
  else do
    do forever
      parse var tmp fld (sep) tmp
      i = i + 1
      call value stemname||i, strip(fld)
      if pos(sep, tmp) = 0 then do
        if tmp <> '' then do
          i = i + 1
          call value stemname||i, strip(tmp)
        end
        leave
      end
    end
  end
  call value stemname||'0', i + 0
  return i

sqlQuote:
  parse arg v
  v = strip(v)
  if v = '' then return 'NULL'
  if translate(v) = 'NULL' then return 'NULL'
  if datatype(v,'NUM') = 1 then return v
  v = changestr("'", v, "''")
  return ''''v''''

/* --- 4) Parse header and detect delimiter --- */
hdr = strip(in.1)
DELIM = detectDelim(hdr)

cols. = ''
ncols = splitLine(hdr, DELIM, 'cols.')
if ncols < 1 then do
  say "ERROR: No columns detected in header. Check delimiter."
  exit 16
end

/* --- 5) Key columns (for UPDATE) --- */
keys. = ''; keycnt = 0
if OP = "UPDATE" then do
  if KEYIN = '' then do
    keycnt = 1
    keys.1 = cols.1
  end
  else do
    /* normalize: accept , ; | spaces; allow indexes or names */
    kraw = translate(KEYIN, ',', ';|')
    kraw = changestr('"', kraw, '')
    kraw = changestr("'", kraw, '')
    do while pos('  ', kraw) > 0; kraw = changestr('  ', kraw, ' '); end
    kraw = translate(kraw, ',', ' ')
    kraw = strip(kraw, 'B', ',')
    do while pos(',,', kraw) > 0; kraw = changestr(',,', kraw, ','); end

    tmpk = kraw
    do forever
      parse var tmpk k ',' tmpk
      k = strip(k); if k = '' then iterate
      picked = ''
      if datatype(k,'W') = 1 then do
        idx = k + 0
        if idx >= 1 & idx <= ncols then picked = cols.idx
      end
      if picked = '' then do
        do i = 1 to ncols
          if translate(cols.i) = translate(k) then do
            picked = cols.i
            leave
          end
        end
      end
      if picked <> '' then do
        dupe = 0
        do j = 1 to keycnt
          if translate(keys.j) = translate(picked) then do; dupe = 1; leave; end
        end
        if dupe = 0 then do
          keycnt = keycnt + 1
          keys.keycnt = picked
        end
      end
      if tmpk = '' then leave
    end

    if keycnt = 0 then do
      say "ERROR: No key columns recognized in: " KEYIN
      exit 20
    end
  end
end

/* Map key column indexes */
kidx. = ''
if OP = "UPDATE" then do
  do j = 1 to keycnt
    kidx.j = 0
    do i = 1 to ncols
      if translate(cols.i) = translate(keys.j) then do
        kidx.j = i
        leave
      end
    end
    if kidx.j = 0 then do
      say 'ERROR: Key column "'keys.j'" not found in header.'
      exit 21
    end
  end
end

/* --- 6) Build SQL into out. (80-char records) --- */
out. = ''; out.0 = 0

/* append string sss to out., wrapped/padded to 80 chars */
app:
  parse arg sss
  if sss = '' then do
    out.0 = out.0 + 1
    idx = out.0
    out.idx = left('', 80)
    return
  end
  do p = 1 to length(sss) by 80
    chunk = substr(sss, p, 80)
    chunk = left(chunk, 80)     /* FB LRECL=80 padding */
    out.0 = out.0 + 1
    idx = out.0
    out.idx = chunk
  end
return

mkSetLine:
  parse arg col, val, islast
  line = '  ' || col || ' = ' || val
  if islast = 0 then line = line || ','
  return line

mkColLine:
  parse arg col, islast
  line = '  ' || col
  if islast = 0 then line = line || ','
  return line

mkValLine:
  parse arg val, islast
  line = '  ' || val
  if islast = 0 then line = line || ','
  return line

/* --- 7) Process data rows --- */
do r = 2 to in.0
  line = strip(in.r)
  if line = '' then iterate

  vals. = ''
  nvals = splitLine(line, DELIM, 'vals.')

  /* align counts */
  if nvals < ncols then do i = nvals+1 to ncols; vals.i = ''; end
  if nvals > ncols then nvals = ncols

  if OP = "UPDATE" then do
    call app 'UPDATE ' || TABLENAME
    call app 'SET'
    do i = 1 to ncols
      iskey = 0
      do j = 1 to keycnt
        if i = kidx.j then do; iskey = 1; leave; end
      end
      if iskey then iterate

      /* find if this is the last non-key col from i..ncols */
      leftcnt = 0
      do t = i to ncols
        isk = 0
        do j = 1 to keycnt
          if t = kidx.j then do; isk = 1; leave; end
        end
        if isk = 0 then leftcnt = leftcnt + 1
      end
      islast = (leftcnt = 1)

      call app mkSetLine(cols.i, sqlQuote(vals.i), islast)
    end

    call app 'WHERE'
    do j = 1 to keycnt
      wi = kidx.j
      wfrag = '  ' || keys.j || ' = ' || sqlQuote(vals.wi)
      if j < keycnt then wfrag = wfrag || ' AND'
      call app wfrag
    end
    call app ';'
    call app ''
  end
  else do  /* INSERT */
    call app 'INSERT INTO ' || TABLENAME || ' ('
    do i = 1 to ncols
      call app mkColLine(cols.i, i = ncols)
    end
    call app ')'
    call app 'VALUES ('
    do i = 1 to ncols
      call app mkValLine(sqlQuote(vals.i), i = ncols)
    end
    call app ');'
    call app ''
  end
end

/* --- 8) Write output dataset FB 80 --- */
"FREE FI(OUTFILE)"
"ALLOC FI(OUTFILE) DA('"OUTBASE'.'"OP"')" NEW CATALOG",
" SPACE(5,5) CYL DSORG(PS) RECFM(F B) LRECL(80) BLKSIZE(0)"
if rc <> 0 then do
  "ALLOC FI(OUTFILE) DA('"OUTBASE'.'"OP"')" MOD REUSE"
  if rc <> 0 then do
    say "ERROR: ALLOC OUTFILE '"OUTBASE'.'"OP""' failed. RC="rc
    exit 24
  end
end

"EXECIO "out.0" DISKW OUTFILE (FINIS STEM out.)"
if rc <> 0 then do
  say "ERROR: Write to OUTFILE failed. RC="rc
  "FREE FI(OUTFILE)"
  exit 28
end
"FREE FI(OUTFILE)"

say "OK: Written "out.0" records to "OUTBASE"."OP
exit 0
