/* REXX - GENSQL: Generate INSERT/UPDATE SQL statements from a data dataset
   - All messages and prompts in English
   - Robust delimiter detection and fallback logic
   - Output: fixed 80-byte dataset <OUTBASE>.(INSERT|UPDATE)
*/
address TSO "CLEAR"
signal MAIN

/* ===== Helper routines ===== */

/* Replace all occurrences of 'old' in 's' with 'new' */
changestr: procedure
  parse arg old, s, new
  if old = '' then return s
  do forever
    p = pos(old, s); if p = 0 then leave
    s = delstr(s, p, length(old))
    s = insert(new, s, p-1)
  end
  return s

/* Detect delimiter: prefer ',', '|', ';', then TAB, finally space */
detectDelim: procedure
  parse arg hdr
  cand = ',|;'
  best = ''; bestcnt = -1
  do i = 1 to length(cand)
    d = substr(cand, i, 1)
    cnt = 0; p = 1
    do while pos(d, hdr, p) > 0
      p = pos(d, hdr, p) + 1
      cnt = cnt + 1
    end
    if cnt > bestcnt then do
      best = d; bestcnt = cnt
    end
  end
  if bestcnt > 0 then return best
  if pos(d2c(9), hdr) > 0 then return d2c(9)
  return ' '

/* Split a string by a delimiter into a stem (e.g., 'cols.') */
splitLine: procedure
  parse arg line, sep, stemname
  if stemname = '' then return 0
  line = strip(line)
  call value stemname||'0', 0
  if line = '' then return 0
  tmp = line; i = 0
  if sep = ' ' then do
    do while tmp <> ''
      parse var tmp fld tmp
      i = i + 1
      call value stemname||i, strip(fld)
    end
  end
  else do
    do forever
      parse var tmp fld (sep) tmp
      i = i + 1
      call value stemname||i, strip(fld)
      if pos(sep, tmp) = 0 then do
        if tmp <> '' then do
          i = i + 1
          call value stemname||i, strip(tmp)
        end
        leave
      end
    end
  end
  call value stemname||'0', i + 0
  return i

/* Quote SQL values properly (NULL, numbers, strings with apostrophes) */
sqlQuote: procedure
  parse arg v
  v = strip(v)
  if v = '' then return 'NULL'
  if translate(v) = 'NULL' then return 'NULL'
  if datatype(v,'NUM') = 1 then return v
  v = changestr("'", v, "''")
  return ''''v''''

/* Append text to out. stem with 80-character wrapping */
app: procedure expose out. out.0
  parse arg sss
  if sss = '' then do
    out.0 = out.0 + 1
    idx = out.0
    out.idx = left('', 80)
    return
  end
  do p = 1 to length(sss) by 80
    chunk = substr(sss, p, 80)
    chunk = left(chunk, 80)
    out.0 = out.0 + 1
    idx = out.0
    out.idx = chunk
  end
  return

mkSetLine: procedure
  parse arg col, val, islast
  line = '  ' || col || ' = ' || val
  if islast = 0 then line = line || ','
  return line

mkColLine: procedure
  parse arg col, islast
  line = '  ' || col
  if islast = 0 then line = line || ','
  return line

mkValLine: procedure
  parse arg val, islast
  line = '  ' || val
  if islast = 0 then line = line || ','
  return line

/* ===== MAIN program ===== */
MAIN:

say "==============================="
say "   SQL GENERATOR (INSERT/UPDATE)"
say "==============================="
say

/* --- 1) User input --- */
do forever
  say "Enter table name (SCHEMA.TABLE):"
  parse upper pull TABLENAME
  TABLENAME = strip(TABLENAME)
  if TABLENAME <> "" & pos('.', TABLENAME) > 0 then leave
  say "ERROR: Use SCHEMA.TABLE format (e.g. MYSCHEMA.MYTABLE)."
end

do forever
  say "Enter input dataset name (e.g. HLQ.INPUT.DATA):"
  parse pull INDSN
  INDSN = strip(INDSN)
  if INDSN <> "" then leave
  say "ERROR: Input dataset cannot be empty."
end

do forever
  say "Enter operation type (INSERT/UPDATE):"
  parse upper pull OP
  OP = strip(OP)
  if OP = "INSERT" | OP = "UPDATE" then leave
  say "ERROR: Only INSERT or UPDATE are supported."
end

KEYIN = ""
if OP = "UPDATE" then do
  say "Enter key columns (names or indexes separated by , ; | or spaces)."
  say "Press ENTER for first column. Example: ID, BRANCH, EFF_DATE or 1,3"
  parse pull KEYIN
  KEYIN = strip(KEYIN)
end

do forever
  say "Enter base name for output dataset (without suffix), e.g. HLQ.OUTPUT.SQL:"
  parse pull OUTBASE
  OUTBASE = strip(OUTBASE)
  if OUTBASE <> "" then leave
  say "ERROR: Output base dataset cannot be empty."
end

OUTDSN = OUTBASE || '.' || OP

/* --- 2) Read input dataset --- */
address TSO
"FREE FI(INFILE)"
"ALLOC FI(INFILE) DA('"INDSN"') SHR REUSE"
if rc <> 0 then do
  say "ERROR: Cannot allocate input dataset '"INDSN"'. RC="rc
  exit 12
end

"EXECIO * DISKR INFILE (FINIS STEM in.)"
if rc <> 0 then do
  say "ERROR: Cannot read input dataset. RC="rc
  "FREE FI(INFILE)"
  exit 12
end
"FREE FI(INFILE)"
if in.0 = 0 then do
  say "ERROR: Input file is empty."
  exit 12
end

/* --- 3) Parse header & detect delimiter (with fallback) --- */
hdr   = strip(in.1)
DELIM = detectDelim(hdr)

cols. = ''
ncols = splitLine(hdr, DELIM, 'cols.')

if ncols < 1 then do
  alts = '|,;'
  ok = 0
  do ai = 1 to length(alts)
    tryd = substr(alts, ai, 1)
    cols. = ''
    ncols = splitLine(hdr, tryd, 'cols.')
    if ncols >= 1 then do
      DELIM = tryd
      ok = 1
      leave
    end
  end
  if ok = 0 then do
    say "ERROR: Could not detect columns in header. Check delimiter."
    say "HEADER: " hdr
    exit 16
  end
end

if DELIM = ' ' then do
  if pos('|', hdr) > 0 then DELIM = '|'
  else if pos(',', hdr) > 0 then DELIM = ','
  else if pos(';', hdr) > 0 then DELIM = ';'
  cols. = ''
  ncols = splitLine(hdr, DELIM, 'cols.')
  if ncols < 1 then do
    say "ERROR: Header could not be parsed even after delimiter correction."
    exit 16
  end
end

/* --- 4) Keys (for UPDATE) --- */
keys. = ''; keycnt = 0
if OP = "UPDATE" then do
  if KEYIN = '' then do
    keycnt = 1
    keys.1 = cols.1
  end
  else do
    kraw = translate(KEYIN, ',', ';|')
    kraw = changestr('"', kraw, '')
    kraw = changestr("'", kraw, '')
    do while pos('  ', kraw) > 0; kraw = changestr('  ', kraw, ' '); end
    kraw = translate(kraw, ',', ' ')
    kraw = strip(kraw, 'B', ',')
    do while pos(',,', kraw) > 0; kraw = changestr(',,', kraw, ','); end

    tmpk = kraw
    do forever
      parse var tmpk k ',' tmpk
      k = strip(k); if k = '' then iterate
      picked = ''
      if datatype(k,'W') = 1 then do
        idx = k + 0
        if idx >= 1 & idx <= ncols then picked = cols.idx
      end
      if picked = '' then do
        do i = 1 to ncols
          if translate(cols.i) = translate(k) then do
            picked = cols.i
            leave
          end
        end
      end
      if picked <> '' then do
        dupe = 0
        do j = 1 to keycnt
          if translate(keys.j) = translate(picked) then do; dupe = 1; leave; end
        end
        if dupe = 0 then do
          keycnt = keycnt + 1
          keys.keycnt = picked
        end
      end
      if tmpk = '' then leave
    end

    if keycnt = 0 then do
      say "ERROR: No key columns recognized in: " KEYIN
      exit 20
    end
  end
end

/* Map key indexes */
kidx. = ''
if OP = "UPDATE" then do
  do j = 1 to keycnt
    kidx.j = 0
    do i = 1 to ncols
      if translate(cols.i) = translate(keys.j) then do
        kidx.j = i
        leave
      end
    end
    if kidx.j = 0 then do
      say 'ERROR: Key column "'keys.j'" not found in header.'
      exit 21
    end
  end
end

/* --- 5) Build SQL in out. (FB 80) --- */
out. = ''; out.0 = 0

do r = 2 to in.0
  line = strip(in.r)
  if line = '' then iterate

  vals. = ''
  nval
