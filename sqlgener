/* REXX - GENSQL: Generate INSERT/UPDATE from a data dataset into FB 80 dataset
   - User prompts in Polish, code comments in English
   - Works in TSO/ISPF. Helper routines are placed below MAIN and use PROCEDURE safely.
*/
address TSO "CLEAR"
signal MAIN

/* ===== Helper routines (called later) ===== */

/* changestr(old, s, new): replace all occurrences of 'old' in 's' with 'new' */
changestr: procedure
  parse arg old, s, new
  if old = '' then return s
  do forever
    p = pos(old, s); if p = 0 then leave
    s = delstr(s, p, length(old))
    s = insert(new, s, p-1)
  end
  return s

/* detectDelim(hdr): prefer non-space delimiters first, space as last resort */
detectDelim: procedure
  parse arg hdr
  alist = '|,;9 B'              /* 9=TAB, B=SPACE */
  best = d2c(32); bestcnt = -1
  do i = 1 to words(alist)
    a = word(alist, i)
    select
      when a = '9' then sep = d2c(9)
      when a = 'B' then sep = d2c(32)
      otherwise        sep = a
    end
    cnt = 0; p = 1
    do while pos(sep, hdr, p) > 0
      p = pos(sep, hdr, p) + 1
      cnt = cnt + 1
    end
    if cnt > bestcnt then do
      best = sep; bestcnt = cnt
    end
  end
  return best

/* splitLine(line, sep, 'stem.'): splits into a caller stem via VALUE(); returns field count */
splitLine: procedure
  parse arg line, sep, stemname
  if stemname = '' then return 0
  line = strip(line)
  call value stemname||'0', 0
  if line = '' then return 0
  tmp = line; i = 0
  if sep = ' ' then do
    do while tmp <> ''
      parse var tmp fld tmp
      i = i + 1
      call value stemname||i, strip(fld)
    end
  end
  else do
    do forever
      parse var tmp fld (sep) tmp
      i = i + 1
      call value stemname||i, strip(fld)
      if pos(sep, tmp) = 0 then do
        if tmp <> '' then do
          i = i + 1
          call value stemname||i, strip(tmp)
        end
        leave
      end
    end
  end
  call value stemname||'0', i + 0
  return i

/* sqlQuote(v): NULL/number passthrough; strings quoted and apostrophes doubled */
sqlQuote: procedure
  parse arg v
  v = strip(v)
  if v = '' then return 'NULL'
  if translate(v) = 'NULL' then return 'NULL'
  if datatype(v,'NUM') = 1 then return v
  v = changestr("'", v, "''")
  return ''''v''''

/* app(sss): append string to out. stem with wrapping/padding to 80 chars */
app: procedure expose out. out.0
  parse arg sss
  if sss = '' then do
    out.0 = out.0 + 1
    idx = out.0
    out.idx = left('', 80)                /* blank 80-char record */
    return
  end
  do p = 1 to length(sss) by 80
    chunk = substr(sss, p, 80)
    chunk = left(chunk, 80)               /* pad to 80 (FB) */
    out.0 = out.0 + 1
    idx = out.0
    out.idx = chunk
  end
  return

/* mkSetLine(col, val, islast) -> "  COL = VAL[ ,]" */
mkSetLine: procedure
  parse arg col, val, islast
  line = '  ' || col || ' = ' || val
  if islast = 0 then line = line || ','
  return line

/* mkColLine(col, islast) -> "  COL[ ,]" */
mkColLine: procedure
  parse arg col, islast
  line = '  ' || col
  if islast = 0 then line = line || ','
  return line

/* mkValLine(val, islast) -> "  VAL[ ,]" */
mkValLine: procedure
  parse arg val, islast
  line = '  ' || val
  if islast = 0 then line = line || ','
  return line

/* ===== MAIN program ===== */
MAIN:

say "==============================="
say "   GENERATOR SQL (INSERT/UPDATE)"
say "==============================="
say

/* --- 1) Robust user input --- */
do forever
  say "Podaj nazwe tabeli (SCHEMA.TAB):"
  parse upper pull TABLENAME
  TABLENAME = strip(TABLENAME)
  if TABLENAME <> "" & pos('.', TABLENAME) > 0 then leave
  say "ERROR: Podaj w formacie SCHEMA.TAB (np. MYSCHEMA.MYTABLE)."
end

do forever
  say "Podaj DSN z danymi (wejscie), np. HLQ.INPUT.DATA:"
  parse pull INDSN
  INDSN = strip(INDSN)
  if INDSN <> "" then leave
  say "ERROR: DSN wejsciowy nie moze byc pusty."
end

do forever
  say "Wybierz operacje (INSERT/UPDATE):"
  parse upper pull OP
  OP = strip(OP)
  if OP = "INSERT" | OP = "UPDATE" then leave
  say "ERROR: Dozwolone tylko INSERT lub UPDATE."
end

KEYIN = ""
if OP = "UPDATE" then do
  say "Podaj kolumny klucza (nazwy lub indeksy, oddzielone , ; | lub spacjami)."
  say "ENTER = 1. kolumna. Przyklad: ID, BRANCH, EFF_DATE lub 1,3"
  parse pull KEYIN
  KEYIN = strip(KEYIN)
end

do forever
  say "Podaj BAZOWA nazwe DSN wyjsciowego (bez sufiksu), np. HLQ.OUTPUT.SQL:"
  parse pull OUTBASE
  OUTBASE = strip(OUTBASE)
  if OUTBASE <> "" then leave
  say "ERROR: Bazowa nazwa DSN wyjsciowego nie moze byc pusta."
end

OUTDSN = OUTBASE || '.' || OP      /* e.g. HLQ.OUTPUT.SQL.UPDATE */

/* --- 2) Read input dataset --- */
address TSO
"FREE FI(INFILE)"
"ALLOC FI(INFILE) DA('"INDSN"') SHR REUSE"
if rc <> 0 then do
  say "ERROR: Nie moge ALLOC INFILE na '"INDSN"'. RC="rc
  exit 12
end

"EXECIO * DISKR INFILE (FINIS STEM in.)"
if rc <> 0 then do
  say "ERROR: Nie moge czytac INFILE. RC="rc
  "FREE FI(INFILE)"
  exit 12
end
"FREE FI(INFILE)"
if in.0 = 0 then do
  say "ERROR: Plik wejsciowy jest pusty."
  exit 12
end

/* --- 3) Parse header & delimiter --- */
hdr   = strip(in.1)
DELIM = detectDelim(hdr)

cols. = ''
ncols = splitLine(hdr, DELIM, 'cols.')
if ncols < 1 then do
  say "ERROR: Nie wykryto kolumn w naglowku. Sprawdz separator."
  exit 16
end

/* --- 4) Keys (for UPDATE) --- */
keys. = ''; keycnt = 0
if OP = "UPDATE" then do
  if KEYIN = '' then do
    keycnt = 1
    keys.1 = cols.1
  end
  else do
    kraw = translate(KEYIN, ',', ';|')               /* ; and | -> , */
    kraw = changestr('"', kraw, '')
    kraw = changestr("'", kraw, '')
    do while pos('  ', kraw) > 0; kraw = changestr('  ', kraw, ' '); end
    kraw = translate(kraw, ',', ' ')
    kraw = strip(kraw, 'B', ',')
    do while pos(',,', kraw) > 0; kraw = changestr(',,', kraw, ','); end

    tmpk = kraw
    do forever
      parse var tmpk k ',' tmpk
      k = strip(k); if k = '' then iterate
      picked = ''
      if datatype(k,'W') = 1 then do                  /* numeric index */
        idx = k + 0
        if idx >= 1 & idx <= ncols then picked = cols.idx
      end
      if picked = '' then do                           /* name match */
        do i = 1 to ncols
          if translate(cols.i) = translate(k) then do
            picked = cols.i
            leave
          end
        end
      end
      if picked <> '' then do
        dupe = 0
        do j = 1 to keycnt
          if translate(keys.j) = translate(picked) then do; dupe = 1; leave; end
        end
        if dupe = 0 then do
          keycnt = keycnt + 1
          keys.keycnt = picked
        end
      end
      if tmpk = '' then leave
    end

    if keycnt = 0 then do
      say "ERROR: Nie rozpoznano zadnych kolumn klucza w: " KEYIN
      exit 20
    end
  end
end

/* Map key indexes */
kidx. = ''
if OP = "UPDATE" then do
  do j = 1 to keycnt
    kidx.j = 0
    do i = 1 to ncols
      if translate(cols.i) = translate(keys.j) then do
        kidx.j = i
        leave
      end
    end
    if kidx.j = 0 then do
      say 'ERROR: Kolumna klucza "'keys.j'" nie istnieje w naglowku.'
      exit 21
    end
  end
end

/* --- 5) Build SQL in out. (FB 80) --- */
out. = ''; out.0 = 0

do r = 2 to in.0
  line = strip(in.r)
  if line = '' then iterate

  vals. = ''
  nvals = splitLine(line, DELIM, 'vals.')

  /* align counts */
  if nvals < ncols then do i = nvals+1 to ncols; vals.i = ''; end
  if nvals > ncols then nvals = ncols

  if OP = "UPDATE" then do
    call app 'UPDATE ' || TABLENAME
    call app 'SET'
    /* emit non-key columns with commas, last one without */
    do i = 1 to ncols
      iskey = 0
      do j = 1 to keycnt
        if i = kidx.j then do; iskey = 1; leave; end
      end
      if iskey then iterate

      /* is this the last non-key column? count remaining non-keys */
      leftcnt = 0
      do t = i to ncols
        isk = 0
        do j = 1 to keycnt
          if t = kidx.j then do; isk = 1; leave; end
        end
        if isk = 0 then leftcnt = leftcnt + 1
      end
      islast = (leftcnt = 1)

      call app mkSetLine(cols.i, sqlQuote(vals.i), islast)
    end

    call app 'WHERE'
    do j = 1 to keycnt
      wi = kidx.j
      wfrag = '  ' || keys.j || ' = ' || sqlQuote(vals.wi)
      if j < keycnt then wfrag = wfrag || ' AND'
      call app wfrag
    end
    call app ';'
    call app ''
  end
  else do  /* INSERT */
    call app 'INSERT INTO ' || TABLENAME || ' ('
    do i = 1 to ncols
      call app mkColLine(cols.i, i = ncols)
    end
    call app ')'
    call app 'VALUES ('
    do i = 1 to ncols
      call app mkValLine(sqlQuote(vals.i), i = ncols)
    end
    call app ');'
    call app ''
  end
end

/* --- 6) Write OUTDSN as FB 80 --- */
"FREE FI(OUTFILE)"
"ALLOC FI(OUTFILE) DA('"OUTDSN"') NEW CATALOG SPACE(5,5) CYL DSORG(PS) RECFM(F B) LRECL(80) BLKSIZE(0)"
if rc <> 0 then do
  "ALLOC FI(OUTFILE) DA('"OUTDSN"') MOD REUSE"
  if rc <> 0 then do
    say "ERROR: ALLOC OUTFILE '"OUTDSN"' nie powiodl sie. RC="rc
    exit 24
  end
end

"EXECIO "out.0" DISKW OUTFILE (FINIS STEM out.)"
if rc <> 0 then do
  say "ERROR: Zapis do OUTDSN nieudany. RC="rc
  "FREE FI(OUTFILE)"
  exit 28
end
"FREE FI(OUTFILE)"

say "OK: Zapisano "out.0" rekordow do "OUTDSN"."
exit 0
